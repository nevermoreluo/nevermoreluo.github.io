<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nevermore Blog</title>
  
  
  <link href="https://nevermoreluo.github.io/atom.xml" rel="self"/>
  
  <link href="https://nevermoreluo.github.io/"/>
  <updated>2023-09-11T05:43:04.313Z</updated>
  <id>https://nevermoreluo.github.io/</id>
  
  <author>
    <name>Nevermore</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux service register script</title>
    <link href="https://nevermoreluo.github.io/2023/09/11/Linux-service-register-script/"/>
    <id>https://nevermoreluo.github.io/2023/09/11/Linux-service-register-script/</id>
    <published>2023-09-11T10:53:39.000Z</published>
    <updated>2023-09-11T05:43:04.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工作中存在一些功能需要注册为服务，保证开机自启以及自动重启业务。其实本质上就是注册一个service unit, 但是很多同学都没搞过。为了减少一些同学的使用成本，就给了个简单脚本按步骤执行。<span id="more"></span> </p><h2 id="Show-me-the-code"><a href="#Show-me-the-code" class="headerlink" title="Show me the code"></a>Show me the code</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e;</span><br><span class="line"></span><br><span class="line">CURRENT_SCRIPT_DIR=$(<span class="built_in">dirname</span> <span class="string">&quot;<span class="subst">$(readlink -f <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 默认来说该注册脚本和程序一起放程序根目录那么CURRENT_SCRIPT_DIR就是项目根目录</span></span><br><span class="line">PROJECT_DIR=<span class="variable">$CURRENT_SCRIPT_DIR</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定服务名称 后续systemctl stop $SERVICE_NAME 用</span></span><br><span class="line">SERVICE_NAME=</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定服务运行程序</span></span><br><span class="line"><span class="comment"># EXEC_FILE=$PROJECT_DIR/$SERVICE_NAME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行程序 这里可以带参数</span></span><br><span class="line"><span class="comment"># 例如 START_CMD=$EXEC_FILE -f $PROJECT_DIR/config.json</span></span><br><span class="line"><span class="comment"># 可能会有启动参数 没有就直接填执行程序</span></span><br><span class="line">START_CMD=<span class="variable">$EXEC_FILE</span></span><br><span class="line"></span><br><span class="line">HAS_START_CMD_ARGS=0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数缺省时，用户交互手动输入</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$SERVICE_NAME</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">read</span> -p <span class="string">&quot;Please set an service name: &quot;</span> SERVICE_NAME</span><br><span class="line">  <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$SERVICE_NAME</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;We can not register service with empty name, bye!!!&quot;</span>;</span><br><span class="line"><span class="built_in">exit</span> 1;</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$EXEC_FILE</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Please set full path for project dir: &quot;</span> PROJECT_DIR</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$PROJECT_DIR</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">PROJECT_DIR=<span class="variable">$CURRENT_SCRIPT_DIR</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Please set full path for exec file: &quot;</span>  EXEC_FILE</span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$HAS_START_CMD_ARGS</span> -ne 0 &amp;&amp; -z <span class="variable">$START_CMD</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">read</span> -p <span class="string">&quot;Please set start cmd: &quot;</span> START_CMD</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    START_CMD=<span class="variable">$EXEC_FILE</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SYSTEM_CONF=/usr/lib/systemd/system/<span class="variable">$SERVICE_NAME</span>.service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;SERVICE_NAME: <span class="variable">$SERVICE_NAME</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PROJECT_DIR: <span class="variable">$PROJECT_DIR</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;EXEC_FILE: <span class="variable">$EXEC_FILE</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;START_CMD: <span class="variable">$START_CMD</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Start install <span class="variable">$SERVICE_NAME</span>...&quot;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$PROJECT_DIR</span></span><br><span class="line"><span class="keyword">if</span> [ -e <span class="variable">$SYSTEM_CONF</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">read</span> -p <span class="string">&quot;Warning!!! <span class="variable">$SERVICE_NAME</span> is already installed. skip install and setup <span class="variable">$SERVICE_NAME</span>? (y/n) &quot;</span> choice</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$choice</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">          y|Y )</span><br><span class="line">              <span class="built_in">echo</span> <span class="string">&quot;Continuing...&quot;</span></span><br><span class="line">              ;;</span><br><span class="line">          n|N )</span><br><span class="line">              <span class="built_in">echo</span> <span class="string">&quot;Exiting...&quot;</span></span><br><span class="line">              <span class="built_in">exit</span> 0</span><br><span class="line">              ;;</span><br><span class="line">          * )</span><br><span class="line">              <span class="built_in">echo</span> <span class="string">&quot;Invalid choice. Exiting...&quot;</span></span><br><span class="line">              <span class="built_in">exit</span> 1</span><br><span class="line">              ;;</span><br><span class="line">      <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Install <span class="variable">$SERVICE_NAME</span>...&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">chmod</span> +x <span class="variable">$EXEC_FILE</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 创建systemd服务文件</span></span><br><span class="line">  <span class="built_in">tee</span> <span class="variable">$SYSTEM_CONF</span> &gt; /dev/null &lt;&lt;<span class="string">EOT</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=$SERVICE_NAME Service</span></span><br><span class="line"><span class="string">After=network.target</span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">Type=simple</span></span><br><span class="line"><span class="string">Restart=always</span></span><br><span class="line"><span class="string">RestartSec=10</span></span><br><span class="line"><span class="string">ExecStart=$START_CMD</span></span><br><span class="line"><span class="string">WorkingDirectory=$PROJECT_DIR</span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOT</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 重新加载systemd服务</span></span><br><span class="line">  systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 启动DeviceBus服务 可能要改配置 先不启动</span></span><br><span class="line">  systemctl start <span class="variable">$SERVICE_NAME</span></span><br><span class="line">  <span class="comment"># 设置开机自启动</span></span><br><span class="line">  systemctl <span class="built_in">enable</span> <span class="variable">$SERVICE_NAME</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Install <span class="variable">$SERVICE_NAME</span> end&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Start program with systemctl start <span class="variable">$SERVICE_NAME</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="Learn-more"><a href="#Learn-more" class="headerlink" title="Learn more"></a>Learn more</h2><ul><li><a href="https://www.bilibili.com/video/BV1Tz4y1s7QW/?spm_id_from=333.337.search-card.all.click&vd_source=c791cc730e25c0810d7b175e322c8dbf">Bilibili Video</a></li><li><a href="https://wiki.archlinuxcn.org/wiki/Systemd">Arch wiki</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;工作中存在一些功能需要注册为服务，保证开机自启以及自动重启业务。其实本质上就是注册一个service unit, 但是很多同学都没搞过。为了减少一些同学的使用成本，就给了个简单脚本按步骤执行。</summary>
    
    
    
    <category term="Code" scheme="https://nevermoreluo.github.io/categories/Code/"/>
    
    
    <category term="linux" scheme="https://nevermoreluo.github.io/tags/linux/"/>
    
    <category term="shell" scheme="https://nevermoreluo.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>监听随机端口</title>
    <link href="https://nevermoreluo.github.io/2022/01/12/%E7%9B%91%E5%90%AC%E9%9A%8F%E6%9C%BA%E7%AB%AF%E5%8F%A3/"/>
    <id>https://nevermoreluo.github.io/2022/01/12/%E7%9B%91%E5%90%AC%E9%9A%8F%E6%9C%BA%E7%AB%AF%E5%8F%A3/</id>
    <published>2022-01-12T10:37:49.000Z</published>
    <updated>2023-09-11T05:43:04.313Z</updated>
    
    <content type="html"><![CDATA[<p>业务上存在需求，一类服务监听随机端口，并由服务发现业务管理内部分配，那么我们如何实现监听随机端口呢？</p><p>实际上将端口设置为0即可在<code>规定</code>范围内，分配一个可bind的端口<span id="more"></span>  </p><p>不论windows还是linux中bind函数传入port为0时，都将随机分配一个端口，相关文档可以查看下面的参考资料  </p><h2 id="随机端口的规定范围"><a href="#随机端口的规定范围" class="headerlink" title="随机端口的规定范围"></a>随机端口的规定范围</h2><p>linux和windows的规定不一致，但是可以由proc配置/注册表等手段修改  </p><blockquote><p>Linux<br>默认为32768 - 60999 之间<br>在文件<code>cat /proc/sys/net/ipv4/ip_local_port_range</code>设定的范围内获取一个随机端口  </p></blockquote><blockquote><p>Windows<br>默认为 49152 - 65535 之间<br>可以修改注册表HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters 修改值</p></blockquote><h2 id="如何获取bind成功的具体端口"><a href="#如何获取bind成功的具体端口" class="headerlink" title="如何获取bind成功的具体端口"></a>如何获取bind成功的具体端口</h2><p>本身业务上随机bind成功之后，需要获取最后成功的bindPort上报给服务发现业务，因此我们在设定端口为0之后,我们可以通过getsockname函数获取当前的句柄bind的端口，<br>下面给定一个简单的linux例子:  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line"><span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(serveraddr);</span><br><span class="line"><span class="type">int</span> bindPort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(sockfd, (sockaddr *)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr)) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Warning(&quot;%s, Failed to bind server socket at address[%s:%s]\n&quot;, __PRETTY_FUNCTION__, ip.data(), port.data());</span></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">getsockname</span>(sockfd, (<span class="keyword">struct</span> sockaddr *) &amp;serveraddr, &amp;len);</span><br><span class="line">bindPort = <span class="built_in">ntohs</span>(serveraddr.sin_port); <span class="comment">// get the real port</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://man7.org/linux/man-pages/man2/bind.2.html">Linux Bind doc</a></li><li><a href="https://man7.org/linux/man-pages/man7/ip.7.html">Linux Ip doc</a></li><li><a href="https://cloud.tencent.com/developer/article/1691625">Linux how to change port range</a></li><li><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winsock/nf-winsock-bind?redirectedfrom=MSDN#remarks">Windows Bind doc</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;业务上存在需求，一类服务监听随机端口，并由服务发现业务管理内部分配，那么我们如何实现监听随机端口呢？&lt;/p&gt;
&lt;p&gt;实际上将端口设置为0即可在&lt;code&gt;规定&lt;/code&gt;范围内，分配一个可bind的端口</summary>
    
    
    
    <category term="Code" scheme="https://nevermoreluo.github.io/categories/Code/"/>
    
    
    <category term="c" scheme="https://nevermoreluo.github.io/tags/c/"/>
    
    <category term="cpp" scheme="https://nevermoreluo.github.io/tags/cpp/"/>
    
    <category term="socket" scheme="https://nevermoreluo.github.io/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>关于游戏同步的二三事</title>
    <link href="https://nevermoreluo.github.io/2022/01/07/%E5%85%B3%E4%BA%8E%E6%B8%B8%E6%88%8F%E5%90%8C%E6%AD%A5%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
    <id>https://nevermoreluo.github.io/2022/01/07/%E5%85%B3%E4%BA%8E%E6%B8%B8%E6%88%8F%E5%90%8C%E6%AD%A5%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/</id>
    <published>2022-01-07T12:00:17.000Z</published>
    <updated>2023-09-11T05:43:04.313Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.skywind.me/blog/archives/112">网络游戏同步法则</a></p><blockquote><p>定义<br>通常来说的状态同步，即狭义上的状态同步，即在状态发生变化时将变动的数据同步给客户端<br>所谓帧同步其实是指以一帧数据为单位进行同步，但是通常来说我们认为的帧同步是 锁定帧同步（或者变种）<br>那么广义上来说，其实存在既是帧同步又是状态同步，即以帧为单位的状态同步<span id="more"></span>  </p></blockquote><h1 id="帧同步基础共识"><a href="#帧同步基础共识" class="headerlink" title="帧同步基础共识"></a>帧同步基础共识</h1><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>A状态 + N个操作 = 确定的B状态  </p><h2 id="同步频率"><a href="#同步频率" class="headerlink" title="同步频率"></a>同步频率</h2><p>看到的一些同步频率都比较高20<del>50次每秒，即20ms</del>50ms<br>本地测试例子时 同步频率超过100ms就能明显的感觉到操作卡顿的感觉  </p><h2 id="什么是锁定帧"><a href="#什么是锁定帧" class="headerlink" title="什么是锁定帧"></a>什么是锁定帧</h2><p>客户端将每帧执行的行为发送给服务端，服务端在每个步进结束时广播当前帧发生的变动，客户端演绎当前帧的变化<br>标准定义下，服务端在未收集到当前帧所有客户端的上报前是不会发送当前帧同步的，即所有客户端需要等最慢的返回，才能获取返回  </p><p>改进乐观锁:<br>固定服务端的帧频，每个固定间隔将收到的客户端行为发送给客户端，并不确保收齐所有客户端当前帧的包，<br>优点: 避免因为最慢的客户端导致全局卡顿<br>缺点: 需要预测行为确保操作流畅，需要回滚修复预测偏差  </p><h2 id="预测帧尽量使得用户操作平滑"><a href="#预测帧尽量使得用户操作平滑" class="headerlink" title="预测帧尽量使得用户操作平滑"></a>预测帧尽量使得用户操作平滑</h2><p>通过对接收数据进行buffer缓存，按帧滑动并根据延迟缩放执行窗口和执行间隔达到平滑效果<br>对于异常、回退帧添加插值帧，例如通过算法预测线性趋势下运行轨迹   </p><h2 id="帧回滚快进，消弭预测帧不正确导致的逻辑异常"><a href="#帧回滚快进，消弭预测帧不正确导致的逻辑异常" class="headerlink" title="帧回滚快进，消弭预测帧不正确导致的逻辑异常"></a>帧回滚快进，消弭预测帧不正确导致的逻辑异常</h2><p>帧回滚是如何实现的，或者说帧切片如何保存现场并恢复，注意这里说的帧切片是逻辑帧而不是渲染帧<br>如何校验是否一致，通用做法是将逻辑帧切片md5后发送到服务器，服务器进行广播</p><p><code>扩展思考：市面上多人游戏中，真的存在A物件运动会影响到10个以上其他物件运动的例子嘛？即在物理引擎展示中的子弹撞击方块山时的情景。如果存在是如何保存恢复逻辑帧的</code></p><h2 id="为什么大多数都是UDP，而不是TCP"><a href="#为什么大多数都是UDP，而不是TCP" class="headerlink" title="为什么大多数都是UDP，而不是TCP"></a>为什么大多数都是UDP，而不是TCP</h2><p>多数例子都是通过udp传输的，通过业务帧序列号保证前端能感知到丢包，并且额外发包降低丢包率（例如每n帧有一帧关键帧，关键帧内包含1~n帧的内容）<br>不过<a href="https://zentia.github.io/2019/04/22/frame-sync/">王者荣耀第一个测试版本</a>也是tcp的，所以目前来说先用tcp先上  </p><blockquote><p>那么为什么不是tcp呢？  </p></blockquote><ul><li>tcp通信本身在网络层存在拥塞控制，在网络状况不好的情况下会导致延迟稍大的情况引发更大的雪崩效应(可以通过切换拥塞算法或者修改TCP_NODELAY缓解，但是无法彻底避免)    </li><li>tcp本身时最求完全可靠和顺序性的，因此，丢包后会持续重传直至该包被确认，否则后续包也不会被上层接收，且重传采用指数避让策略，决定重传时间间隔的RTO (Retransmission Timeout)不可控制，Linux内核实现中最低值为200ms</li></ul><blockquote><p>可能存在的一些TCP优化方案：  </p></blockquote><ul><li>切换拥塞算法bbr或者修改TCP_NODELAY</li><li>基于UDP定制传输层协议，引入顺序性和适当程度或者可调节程度的可靠性，修改流控算法。适当放弃重传，如：设置最大重传次数，即使重传失败，也不需要重新建立连接。比较知名的TCP加速开源方案有：quic、enet、kcp、udt。其中，quic是源自google的TCP替代方案，其主要目的是为了整合TCP协议的可靠性和UDP协议的速度和效率，其主要特性包括：避免前序包阻塞、减少数据包、向前纠错、会话重启和并行下载等，然而QUIC对标的是TCP+TLS+SPDY，相比其他方案更重，目前国内用于网络游戏较少。kcp的作者是国内优秀开发者，社区也发展良好，kcp的作者和社区开发者对enet、kcp、udt做了性能测试，详情可参见：<a href="https://github.com/skywind3000/kcp/wiki/KCP-Benchmark%EF%BC%8C">https://github.com/skywind3000/kcp/wiki/KCP-Benchmark，</a> 从测试情况可以看到，kcp表现不错，其次是enet，表现最差的是udt。</li></ul><h2 id="实现一个帧同步游戏我们需要什么"><a href="#实现一个帧同步游戏我们需要什么" class="headerlink" title="实现一个帧同步游戏我们需要什么"></a>实现一个帧同步游戏我们需要什么</h2><blockquote><p>物理引擎至少需要满足以下两点<br>根据冲量驱动对象移动<br>碰撞分离，两个对象重叠后如何根据冲量，位置，时间信息计算出不分离后的位置</p></blockquote><blockquote><p>定点数运算，即一个数值稳定的物理引擎</p></blockquote><blockquote><p>拥有一个稳定的tick驱动物理引擎, 注意实现过程中帧会被其他逻辑拖累，我们需要一个独立并且稳定的帧频，这是物理引擎结果一致性的必要条件  </p></blockquote><blockquote><p>增加udp通信 不是所有情况下udp都是通的，只有在udp连上的时候采用udp 因此传统做法都是先建立tcp</p></blockquote><blockquote><p>伪随机数</p></blockquote><blockquote><p>提高同步频率，尽量不要低于物理引擎渲染帧的3倍</p></blockquote><h2 id="同步逻辑参考："><a href="#同步逻辑参考：" class="headerlink" title="同步逻辑参考："></a>同步逻辑参考：</h2><ul><li><a href="https://zentia.github.io/2019/04/22/frame-sync/">https://zentia.github.io/2019/04/22/frame-sync/</a></li><li><a href="http://clintonbrennan.com/2013/12/lockstep-implementation-in-unity3d/">http://clintonbrennan.com/2013/12/lockstep-implementation-in-unity3d/</a></li><li><a href="https://www.daimajiaoliu.com/daima/56b2d86c9ab0001">https://www.daimajiaoliu.com/daima/56b2d86c9ab0001</a></li><li><a href="https://blog.codingnow.com/2018/08/lockstep.html">https://blog.codingnow.com/2018/08/lockstep.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/344600774">https://zhuanlan.zhihu.com/p/344600774</a></li><li><a href="http://www.vvbin.com/?p=860">http://www.vvbin.com/?p=860</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://www.skywind.me/blog/archives/112&quot;&gt;网络游戏同步法则&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;定义&lt;br&gt;通常来说的状态同步，即狭义上的状态同步，即在状态发生变化时将变动的数据同步给客户端&lt;br&gt;所谓帧同步其实是指以一帧数据为单位进行同步，但是通常来说我们认为的帧同步是 锁定帧同步（或者变种）&lt;br&gt;那么广义上来说，其实存在既是帧同步又是状态同步，即以帧为单位的状态同步</summary>
    
    
    
    <category term="Code" scheme="https://nevermoreluo.github.io/categories/Code/"/>
    
    
    <category term="game" scheme="https://nevermoreluo.github.io/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>Strace</title>
    <link href="https://nevermoreluo.github.io/2022/01/07/Strace/"/>
    <id>https://nevermoreluo.github.io/2022/01/07/Strace/</id>
    <published>2022-01-07T11:38:44.000Z</published>
    <updated>2023-09-11T05:43:04.313Z</updated>
    
    <content type="html"><![CDATA[<p>Strace是Linux环境下用于调试诊断应用程序调用systemcall的工具。</p><p>由于Strace只检测系统调用，因此Strace只是一个分析的侧面。<br>例如：命令<code>perl -e &#39;while(1)&#123;&#125;&#39;</code>不会产生任何系统调用</p><p>系统调用包括以下几个方面file, process, network, signal, ipc, desc， 默认将检测所有系统调用即all<span id="more"></span></p><h2 id="使用Strace统计运行期间系统调用占比"><a href="#使用Strace统计运行期间系统调用占比" class="headerlink" title="使用Strace统计运行期间系统调用占比"></a>使用Strace统计运行期间系统调用占比</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ sudo strace -f -c main</span><br><span class="line">strace: Process 30879 detached</span><br><span class="line">% time     seconds  usecs/call     calls    errors syscall</span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line"> 64.79    2.184606       35236        62         3 futex</span><br><span class="line"> 28.13    0.948503         566      1675         1 clock_nanosleep</span><br><span class="line">  2.85    0.096019           8     12105           getsockopt</span><br><span class="line">  1.35    0.045417           3     16768           mprotect</span><br><span class="line">  0.82    0.027561           7      4002      3633 recvfrom</span><br><span class="line">  0.65    0.021963           3      7108           lseek</span><br><span class="line"> ...</span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line">100.00    3.371847                 55680      5957 total</span><br></pre></td></tr></table></figure><h2 id="使用Strace-记录程序运行期间的系统调用"><a href="#使用Strace-记录程序运行期间的系统调用" class="headerlink" title="使用Strace 记录程序运行期间的系统调用"></a>使用Strace 记录程序运行期间的系统调用</h2><p>可以通过添加-tt记录调用时间戳，与程序日志对比可区分出程序各个阶段的系统调用  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo strace -f -tt -T -o /tmp/test/trace.log main</span><br><span class="line"></span><br><span class="line">$ cat /tmp/test/trace.log</span><br><span class="line">18721 21:02:31.936942 execve(&quot;/bin/bash&quot;, [&quot;bash&quot;, &quot;-c&quot;, &quot;APOWO_SERVER_ROOT=/home/never/wo&quot;...], 0x7ffef5c46408 /* 14 vars */) = 0 &lt;0.000077&gt;</span><br><span class="line">18721 21:02:31.937082 brk(NULL)         = 0x563070e9c000 &lt;0.000017&gt;</span><br><span class="line">18721 21:02:31.937133 arch_prctl(0x3001 /* ARCH_??? */, 0x7ffe20222180) = -1 EINVAL (Invalid argument) &lt;0.000017&gt;</span><br><span class="line">18721 21:02:31.937183 access(&quot;/etc/ld.so.preload&quot;, R_OK) = -1 ENOENT (No such file or directory) &lt;0.000019&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PID  调用时间 系统调用名称 返回 消耗时间  </span><br><span class="line">18721 21:02:31.936942 execve(&quot;/bin/bash&quot;, [&quot;bash&quot;, &quot;-c&quot;, &quot;APOWO_SERVER_ROOT=/home/never/wo&quot;...], 0x7ffef5c46408 /* 14 vars */) = 0 &lt;0.000077&gt; </span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://linux.die.net/man/1/strace">https://linux.die.net/man/1/strace</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Strace是Linux环境下用于调试诊断应用程序调用systemcall的工具。&lt;/p&gt;
&lt;p&gt;由于Strace只检测系统调用，因此Strace只是一个分析的侧面。&lt;br&gt;例如：命令&lt;code&gt;perl -e &amp;#39;while(1)&amp;#123;&amp;#125;&amp;#39;&lt;/code&gt;不会产生任何系统调用&lt;/p&gt;
&lt;p&gt;系统调用包括以下几个方面file, process, network, signal, ipc, desc， 默认将检测所有系统调用即all</summary>
    
    
    
    <category term="Code" scheme="https://nevermoreluo.github.io/categories/Code/"/>
    
    
    <category term="linux" scheme="https://nevermoreluo.github.io/tags/linux/"/>
    
    <category term="cpp" scheme="https://nevermoreluo.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>关于Core dump(核心转储)</title>
    <link href="https://nevermoreluo.github.io/2022/01/07/%E5%85%B3%E4%BA%8ECore-dump-%E6%A0%B8%E5%BF%83%E8%BD%AC%E5%82%A8/"/>
    <id>https://nevermoreluo.github.io/2022/01/07/%E5%85%B3%E4%BA%8ECore-dump-%E6%A0%B8%E5%BF%83%E8%BD%AC%E5%82%A8/</id>
    <published>2022-01-07T10:18:54.000Z</published>
    <updated>2023-09-11T05:43:04.313Z</updated>
    
    <content type="html"><![CDATA[<p>core dump是程序运行时，在进程收到某些信号而终止运行时，将此时进程地址空间的内容以及有关进程状态的其他信息写入一个磁盘文件。</p><p>对应会产生core dump的信号  </p><table><thead><tr><th>Signal</th><th>Action</th><th>Comment</th></tr></thead><tbody><tr><td>SIGQUIT</td><td>Core</td><td>Quit from keyboard</td></tr><tr><td>SIGILL</td><td>Core</td><td>Illegal Instruction</td></tr><tr><td>SIGABRT</td><td>Core</td><td>Abort signal from abort</td></tr><tr><td>SIGSEGV</td><td>Core</td><td>Invalid memory reference</td></tr><tr><td>SIGTRAP</td><td>Core</td><td>Trace/breakpoint trap</td></tr></tbody></table><p>我们可以通过使用gdb查core dump文件，最后崩溃时的信息，来进行debug<br>为了更好的查看阅读core dump文件, linux下需要进行以下配置<span id="more"></span> </p><h2 id="设置core文件生成位置，-默认为当前目录"><a href="#设置core文件生成位置，-默认为当前目录" class="headerlink" title="设置core文件生成位置， 默认为当前目录"></a>设置core文件生成位置， 默认为当前目录</h2><p>可以修改/proc/sys/kernel/core_pattern，将core文件生成到指定目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /cores</span><br><span class="line">echo &quot;/cores/core.%t.%e.%p&quot; | sudo tee /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p>参数包含</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%e  Executable name</span><br><span class="line">%h  Hostname</span><br><span class="line">%p  PID of dumped process</span><br><span class="line">%s  Signal causing dump</span><br><span class="line">%t  Time of dump</span><br><span class="line">%u  UID</span><br><span class="line">%g  GID</span><br></pre></td></tr></table></figure><h2 id="设置系统ulimit-core-size"><a href="#设置系统ulimit-core-size" class="headerlink" title="设置系统ulimit core size"></a>设置系统ulimit core size</h2><p>可以通过<code>ulimit -c</code> 查看当前 core size， 默认为0，即不会生成core dump文件</p><ul><li>通过<code>ulimit -c unlimited</code>设置当前会话中的ulimit， 退出或者新开会话会失效</li><li>为docker 设置ulimit， 默认会跟随 dockerd的配置，也可以在运行时指定 <code>docker run --ulimit core=-1 --security-opt seccomp=unconfined -v /cores:/cores &lt;后续命令&gt;</code></li><li>在程序中直接设定，下面是一个例子</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CORE_SIZE   -1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rlimit</span> rlmt;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getrlimit</span>(RLIMIT_CORE, &amp;rlmt) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before set rlimit CORE dump current is:%d, max is:%d\n&quot;</span>, (<span class="type">int</span>)rlmt.rlim_cur, (<span class="type">int</span>)rlmt.rlim_max);</span><br><span class="line"></span><br><span class="line">    rlmt.rlim_cur = (<span class="type">rlim_t</span>)CORE_SIZE;</span><br><span class="line">    rlmt.rlim_max  = (<span class="type">rlim_t</span>)CORE_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="comment">// 主要是这句 设定 core size</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setrlimit</span>(RLIMIT_CORE, &amp;rlmt) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;   </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getrlimit</span>(RLIMIT_CORE, &amp;rlmt) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After set rlimit CORE dump current is:%d, max is:%d\n&quot;</span>, (<span class="type">int</span>)rlmt.rlim_cur, (<span class="type">int</span>)rlmt.rlim_max);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*测试非法内存，产生core文件*/</span></span><br><span class="line">    <span class="type">int</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line">    *ptr = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们大多数工程测试时都是跑在clion+wsl环境中的， 当clion启动wsl时会通过 wsl另外启动一个sh的壳导致我们在系统内部设置的ulimit失效，所以我们项目中选择在程序内设定。 通过<code>C:\Windows\system32\wsl.exe --distribution Ubuntu-18.04 --exec /bin/sh -c &quot;ulimit -c&quot;</code>可以验证  </p><h2 id="添加编译参数，在查看core-dump文件时可以拿到更详细的信息"><a href="#添加编译参数，在查看core-dump文件时可以拿到更详细的信息" class="headerlink" title="添加编译参数，在查看core dump文件时可以拿到更详细的信息"></a>添加编译参数，在查看core dump文件时可以拿到更详细的信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CMakeLists.txt</span><br><span class="line">        add_definitions(-DDEBUG=true)</span><br><span class="line">        add_definitions(-DRELEASE=false)</span><br><span class="line"></span><br><span class="line">        # core dump config</span><br><span class="line">        add_definitions(&quot;$ENV&#123;CXXFLAGS&#125; -O0 -g&quot;)</span><br><span class="line">        SET(CMAKE_CXX_FLAGS_DEBUG &quot;$ENV&#123;CXXFLAGS&#125; -O0 -g&quot;)</span><br></pre></td></tr></table></figure><h2 id="至此-当程序异常退出时，我们可以在debug环境下愉快的拿到core文件了"><a href="#至此-当程序异常退出时，我们可以在debug环境下愉快的拿到core文件了" class="headerlink" title="至此 当程序异常退出时，我们可以在debug环境下愉快的拿到core文件了"></a>至此 当程序异常退出时，我们可以在debug环境下愉快的拿到core文件了</h2><p>假设core文件为<code>/cores/core.1630405848.pixelpai.19</code>,我们就可以通过gdb解析对应的文件<br>bt # 获取最后退出堆栈的详细信息<br>frame 3 # 简写 f 3 切到第3个frame 并输出相关代码<br>p value # 展示所在帧value对象的值<br>up # 移到上一个帧<br>down # 移到下一个帧  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">gdb main /cores/core.1630405848.pixelpai.19</span><br><span class="line">...</span><br><span class="line">GNU gdb (Ubuntu 8.1.1-0ubuntu1) 8.1.1</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Reading symbols from cmake-build-debug/build/bin/main...done.</span><br><span class="line">[New LWP 17765]</span><br><span class="line">[New LWP 2336]</span><br><span class="line">[New LWP 29510]</span><br><span class="line">[New LWP 11379]</span><br><span class="line">[New LWP 2335]</span><br><span class="line">[New LWP 2334]</span><br><span class="line">[New LWP 20475]</span><br><span class="line">[New LWP 20476]</span><br><span class="line">[New LWP 20477]</span><br><span class="line"></span><br><span class="line">warning: Could not load shared library symbols for 2 libraries, e.g. ./cjson.so.</span><br><span class="line">Use the &quot;info sharedlibrary&quot; command to see the complete listing.</span><br><span class="line">Do you need &quot;set solib-search-path&quot; or &quot;set sysroot&quot;?</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span><br><span class="line">Core was generated by `/home/never/work/pixelpai_server/cmake-build-debug/build/bin/main -props /home/&#x27;.</span><br><span class="line">Program terminated with signal SIGABRT, Aborted.</span><br><span class="line">#0  raise (sig=&lt;optimized out&gt;) at ../sysdeps/unix/sysv/linux/raise.c:50</span><br><span class="line">50      ../sysdeps/unix/sysv/linux/raise.c: No such file or directory.</span><br><span class="line">[Current thread is 1 (Thread 0x7fca28917700 (LWP 17765))]</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  raise (sig=&lt;optimized out&gt;) at ../sysdeps/unix/sysv/linux/raise.c:50</span><br><span class="line">#1  0x0000562abaf64e47 in console::handler (sig=11) at /home/never/work/pixelpai_server/src/server/main/console_linux.cpp:244</span><br><span class="line">#2  &lt;signal handler called&gt;</span><br><span class="line">#3  0x00007fca316e0108 in Sprite::getSpriteSerialize (this=0x7fca00a66d00) at /home/never/work/pixelpai_server/src/server/world/virtualworld/scene/sprite.cpp:595</span><br><span class="line">#4  0x00007fca3169a87a in Scene::sendEnterSceneToAll (this=0x7fca0217ba60, actorId=1685436067) at /home/never/work/pixelpai_server/src/server/world/virtualworld/scene/scene.cpp:535</span><br><span class="line">...</span><br><span class="line">(gdb) frame 3</span><br><span class="line">#3  0x00007fca316e0108 in Sprite::getSpriteSerialize (this=0x7fca00a66d00) at /home/never/work/pixelpai_server/src/server/world/virtualworld/scene/sprite.cpp:595</span><br><span class="line">(gdb) p animationSptr</span><br><span class="line">$1 = std::shared_ptr&lt;IAnimation&gt; (empty) = &#123;get() = 0x0&#125;</span><br><span class="line">(gdb) p spriteSptr</span><br><span class="line">$2 = std::shared_ptr&lt;op_client::Sprite&gt; (use count 1, weak count 0) = &#123;get() = 0x7fca0d84cea0&#125;</span><br><span class="line">(gdb) up</span><br><span class="line">#4  0x00007fca3169a87a in Scene::sendEnterSceneToAll (this=0x7fca0217ba60, actorId=1685436067) at /home/never/work/pixelpai_server/src/server/world/virtualworld/scene/scene.cpp:535</span><br><span class="line">535         auto characterProto = pCharacter-&gt;getSpriteSerialize();</span><br><span class="line">(gdb) down</span><br><span class="line">#3  0x00007fca316e0108 in Sprite::getSpriteSerialize (this=0x7fca00a66d00) at /home/never/work/pixelpai_server/src/server/world/virtualworld/scene/sprite.cpp:595</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ctring.github.io/blog/2021/how-to-get-core-dump-in-a-Docker-container/">https://ctring.github.io/blog/2021/how-to-get-core-dump-in-a-Docker-container/</a><br><a href="https://le.qun.ch/en/blog/core-dump-file-in-docker/">https://le.qun.ch/en/blog/core-dump-file-in-docker/</a><br><a href="https://zhuanlan.zhihu.com/p/24311785">https://zhuanlan.zhihu.com/p/24311785</a><br><a href="https://www.cnblogs.com/hazir/p/linxu_core_dump.html">https://www.cnblogs.com/hazir/p/linxu_core_dump.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;core dump是程序运行时，在进程收到某些信号而终止运行时，将此时进程地址空间的内容以及有关进程状态的其他信息写入一个磁盘文件。&lt;/p&gt;
&lt;p&gt;对应会产生core dump的信号  &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Signal&lt;/th&gt;
&lt;th&gt;Action&lt;/th&gt;
&lt;th&gt;Comment&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;SIGQUIT&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td&gt;Quit from keyboard&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SIGILL&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td&gt;Illegal Instruction&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SIGABRT&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td&gt;Abort signal from abort&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SIGSEGV&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td&gt;Invalid memory reference&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SIGTRAP&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td&gt;Trace/breakpoint trap&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;我们可以通过使用gdb查core dump文件，最后崩溃时的信息，来进行debug&lt;br&gt;为了更好的查看阅读core dump文件, linux下需要进行以下配置</summary>
    
    
    
    <category term="Code" scheme="https://nevermoreluo.github.io/categories/Code/"/>
    
    
    <category term="linux" scheme="https://nevermoreluo.github.io/tags/linux/"/>
    
    <category term="c" scheme="https://nevermoreluo.github.io/tags/c/"/>
    
    <category term="cpp" scheme="https://nevermoreluo.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Lua 源码中 l_likely, l_unlikey 是什么意思</title>
    <link href="https://nevermoreluo.github.io/2022/01/07/Lua-%E6%BA%90%E7%A0%81%E4%B8%AD-l-likely-l-unlikey-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/"/>
    <id>https://nevermoreluo.github.io/2022/01/07/Lua-%E6%BA%90%E7%A0%81%E4%B8%AD-l-likely-l-unlikey-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</id>
    <published>2022-01-07T10:04:14.000Z</published>
    <updated>2023-09-11T05:43:04.313Z</updated>
    
    <content type="html"><![CDATA[<p>最近在排查c++程序内部调用lua_pcall时产生<code>C stack overflow</code>异常，<br>研究问题时发现lua源码中存在一些likely调用,其实在其他代码中也见到过类似的调用，<br>那么我们今天就来探究一下它到底是什么逻辑<span id="more"></span>    </p><p>lua代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 校验c层的nCcalls调用计数</span></span><br><span class="line"><span class="comment">// getCcalls函数返回lua层调用c层回调call的计数值</span></span><br><span class="line"><span class="comment">// LUAI_MAXCCALLS 是调用限制的宏定义 5.4中定义为200</span></span><br><span class="line"><span class="comment">// 即如果调用超过200时 调用luaE_checkcstack 引发异常</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">l_unlikely</span>(<span class="built_in">getCcalls</span>(L) &gt;= LUAI_MAXCCALLS))</span><br><span class="line">    <span class="built_in">luaE_checkcstack</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l_likely(x)luai_likely(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l_unlikely(x)luai_unlikely(x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** macros to improve jump prediction, used mostly for error handling</span></span><br><span class="line"><span class="comment">** and debug facilities. (Some macros in the Lua API use these macros.</span></span><br><span class="line"><span class="comment">** Define LUA_NOBUILTIN if you do not want &#x27;__builtin_expect&#x27; in your</span></span><br><span class="line"><span class="comment">** code.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(luai_likely)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(__GNUC__) &amp;&amp; !defined(LUA_NOBUILTIN)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> luai_likely(x)(__builtin_expect(((x) != 0), 1))</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> luai_unlikely(x)(__builtin_expect(((x) != 0), 0))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> luai_likely(x)(x)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> luai_unlikely(x)(x)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>好，直到这里我们发现这是一个编译时的宏定义，甚至在某些特定情况下l_likely和l_unlikely调用了和没调用没区别<br>即不论<code>if (l_likely(r))</code>还是<code>if (l_unlikely(r))</code> 在逻辑语义上是完全等价于<code>if (r) </code> </p><h2 id="那么，什么是-builtin-expect"><a href="#那么，什么是-builtin-expect" class="headerlink" title="那么，什么是__builtin_expect ?"></a>那么，什么是__builtin_expect ?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Built-in Function: long __builtin_expect (long EXP, long C)</span><br><span class="line">You may use `__builtin_expect&#x27; to provide the compiler with branch prediction information.</span><br><span class="line">The return value is the value of EXP, which should be an integral  expression.  The value of C must be a compile-time constant.  The semantics of the built-in are that it is expected that EXP == C.</span><br><span class="line"></span><br><span class="line">For example:</span><br><span class="line">    if (__builtin_expect (x, 0))</span><br><span class="line">        foo ();</span><br><span class="line"></span><br><span class="line">would indicate that we do not expect to call `foo&#x27;, since we expect `x&#x27; to be zero.  Since you are limited to integral expressions for EXP, you should use constructions such as</span><br><span class="line">    if (__builtin_expect (ptr != NULL, 1))</span><br><span class="line">        error ();</span><br><span class="line">when testing pointer or floating-point values.</span><br></pre></td></tr></table></figure><p>乍一看满头问号，预测信息？ 不对啊，只有我写代码才是玄学才对啊（不是  </p><p>其实是这样的，这个函数是gcc提供的为编译优化处理的函数，并不会对逻辑语义造成影响<br>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (l_ulikely(&lt;绝大多数情况都不会为真&gt;)) &#123;</span><br><span class="line">    // do if</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // do else</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述语句中，在gcc(&gt;=2.96)编译的情况下，编译器将会把else部分的逻辑进行编译优化，以期待减少指令跳转带来的性能损耗<br>那么具体优化了啥呢？<br>现在处理器都是流水线的，有些里面有多个逻辑运算单元，系统可以提前取多条指令进行并行处理，但遇到跳转时，则需要重新取指令，这相对于不用重新去指令就降低了速度。<br>目的是增加条件分支预测的准确性，cpu会提前装载后面的指令，遇到条件转移指令时会提前预测并装载某个分支的指令。unlikely 表示你可以确认该条件是极少发生的，相反 likely 表示该条件多数情况下会发生。编译器会产生相应的代码来优化 cpu 执行效率。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不论<code>if (l_likely(r))</code>还是<code>if (l_unlikely(r))</code> 在逻辑语义上是完全等价于<code>if (r) </code><br>我们可能会在大多数地方找到不一样名字关于likely/unlikely的宏定义，<br>函数本质上是为了编译时优化逻辑跳转减少重新取指令的开销，并不会影响实际的逻辑语义  </p><p>因此，在你十分确信绝大多数情况下为真时使用likely,或者在你十分确信绝大多数情况下为假时使用unlikely.<br>例如问题最开始的<code>if (l_unlikely(getCcalls(L) &gt;= LUAI_MAXCCALLS))</code>, 因为正常情况下不可能引发<code>C Stack Overflow</code>的异常  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在排查c++程序内部调用lua_pcall时产生&lt;code&gt;C stack overflow&lt;/code&gt;异常，&lt;br&gt;研究问题时发现lua源码中存在一些likely调用,其实在其他代码中也见到过类似的调用，&lt;br&gt;那么我们今天就来探究一下它到底是什么逻辑</summary>
    
    
    
    <category term="Code" scheme="https://nevermoreluo.github.io/categories/Code/"/>
    
    
    <category term="lua" scheme="https://nevermoreluo.github.io/tags/lua/"/>
    
    <category term="c" scheme="https://nevermoreluo.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>回退git远程提交</title>
    <link href="https://nevermoreluo.github.io/2022/01/06/%E5%9B%9E%E9%80%80git%E8%BF%9C%E7%A8%8B%E6%8F%90%E4%BA%A4/"/>
    <id>https://nevermoreluo.github.io/2022/01/06/%E5%9B%9E%E9%80%80git%E8%BF%9C%E7%A8%8B%E6%8F%90%E4%BA%A4/</id>
    <published>2022-01-06T20:40:57.000Z</published>
    <updated>2023-09-11T05:43:04.313Z</updated>
    
    <content type="html"><![CDATA[<p>严格意义上来说，我们并不期待撤销一个已经提交的commit（虽然我们可以）<br>下面给出4种解决方式，各有优缺点<span id="more"></span>  </p><h2 id="使用git-revert，-推荐但是比较麻烦"><a href="#使用git-revert，-推荐但是比较麻烦" class="headerlink" title="使用git revert， 推荐但是比较麻烦"></a>使用<code>git revert</code>， 推荐但是比较麻烦</h2><blockquote><p>推荐使用<code>git revert</code>实现,将某一个提交生成一个完全相反的改动并提交</p></blockquote><p>假设我们当前在main分支上commit如下， 当前在0223037e，期待回退到8266909f上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commit 0223037e</span><br><span class="line">commit 37a67ef8</span><br><span class="line">commit 8266909f</span><br></pre></td></tr></table></figure><ul><li>不包含merge提交<br>此时我们只用依次回退0223037e以及37a67ef8即可<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git revert --no-commit 0223037e</span><br><span class="line">$ git revert --no-commit 37a67ef8</span><br><span class="line"></span><br><span class="line"># or 等价于</span><br><span class="line">$ git revert --no-commit 37a67ef8...0223037e</span><br></pre></td></tr></table></figure></li></ul><p>之后就正常commit+push即可</p><ul><li>包含merge提交<br>现在假定0223037e为merge提交，由dev merge main，我们当前在main分支上<br>此时当我们执行git revert –no-commit 0223037e会报错 <code>0223037e is a merge but no -m option was given.</code><br>此时命令应该改为<code>git revert --no-commit 0223037e -m 1</code><br>剩下的逻辑跟不包含merge的提交一致即可<br><code>-m</code>参数后面是parentNumber, 官方文档是说 <code>This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.</code><br>翻译一下就是，当你在 B 分支上把 A merge 到 B 中，那么 B 就是merge commit 的 parent1，而 A 是 parent2。</li></ul><h2 id="直接git-reset-–hard，-省力但是如果有很多人和你协同工作的话，-藏好他们的刀"><a href="#直接git-reset-–hard，-省力但是如果有很多人和你协同工作的话，-藏好他们的刀" class="headerlink" title="直接git reset –hard， 省力但是如果有很多人和你协同工作的话， 藏好他们的刀"></a>直接git reset –hard， 省力但是如果有很多人和你协同工作的话， 藏好他们的刀</h2><blockquote><p>–hard 之后修改了git commit的index，因此期待提交时必须要通过git push -f,<br>但是一旦你强行将push上去了之后，这回导致其他获取项目的同事需要面临无法正常git pull或者无法正常git push的情况</p></blockquote><h2 id="git-diff-–binary-HEAD-commit-sha-you-want-to-revert-to-git-apply"><a href="#git-diff-–binary-HEAD-commit-sha-you-want-to-revert-to-git-apply" class="headerlink" title="git diff –binary HEAD commit_sha_you_want_to_revert_to | git apply"></a>git diff –binary HEAD commit_sha_you_want_to_revert_to | git apply</h2><blockquote><p>存在缺陷部分无法通过git diff获取变更的无法使用该命令例如png</p></blockquote><h2 id="手动通过git-reset-–hard拿到一份想要的内容，git-pull-拉去到最新的-然后将之前的内容覆盖回来"><a href="#手动通过git-reset-–hard拿到一份想要的内容，git-pull-拉去到最新的-然后将之前的内容覆盖回来" class="headerlink" title="手动通过git reset –hard拿到一份想要的内容，git pull 拉去到最新的 然后将之前的内容覆盖回来"></a>手动通过git reset –hard拿到一份想要的内容，git pull 拉去到最新的 然后将之前的内容覆盖回来</h2><p>朴实无华</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://git-scm.com/docs/git-revert#git-revert--mparent-number">https://git-scm.com/docs/git-revert#git-revert--mparent-number</a><br><a href="https://stackoverflow.com/questions/1463340/how-to-revert-multiple-git-commits">https://stackoverflow.com/questions/1463340/how-to-revert-multiple-git-commits</a><br><a href="https://juejin.cn/post/6844903590545506312">https://juejin.cn/post/6844903590545506312</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;严格意义上来说，我们并不期待撤销一个已经提交的commit（虽然我们可以）&lt;br&gt;下面给出4种解决方式，各有优缺点</summary>
    
    
    
    <category term="Code" scheme="https://nevermoreluo.github.io/categories/Code/"/>
    
    
    <category term="git" scheme="https://nevermoreluo.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>NSIS打包C# 程序</title>
    <link href="https://nevermoreluo.github.io/2022/01/06/NSIS%E6%89%93%E5%8C%85C-%E7%A8%8B%E5%BA%8F/"/>
    <id>https://nevermoreluo.github.io/2022/01/06/NSIS%E6%89%93%E5%8C%85C-%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-01-06T20:13:01.000Z</published>
    <updated>2023-09-11T05:43:04.313Z</updated>
    
    <content type="html"><![CDATA[<p>NSIS是一个Nullsoft脚本安装系统（英语：Nullsoft Scriptable Install System，缩写：NSIS）为一个开放源代码脚本驱动的封装安装档用工具。可以用其脚本语言自定安装的流程，同时支持多种语系的安装接口。<span id="more"></span>  </p><h2 id="安装NSIS"><a href="#安装NSIS" class="headerlink" title="安装NSIS"></a>安装NSIS</h2><p>有些人建议安装Unicode NSIS，NSIS3.0.1版本已经兼容了unicode，除非是老版本的，可以考虑安装Unicode NSIS。<br><a href="https://nsis.sourceforge.io/Download">NSIS下载地址</a></p><p>下载安装完成后，可以在桌面看到一个NSIS的图标，先别急着打开它，现在我们还用不上它。</p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>安装一些常用插件（以下插件均为按需安装，如果不需要也可以选择不安装）</p><p>AccessControl.dll : 它提供了一组与Windows NT访问控制列表（ACL）管理相关的功能，相当于设定目录权限的功能。 <a href="https://nsis.sourceforge.io/AccessControl_plug-in">下载地址</a><br>KillProcDLL.dll：关闭指定名称的exe,用于卸载时关闭进程。<a href="https://nsis.sourceforge.io/KillProcDLL_plug-in">下载地址</a><br>liteFirewall.dll： 关闭防火墙<a href="https://leons.im/portfolio/nsis-plugin-litefirewall/">下载地址</a><br>UAC.dll，UAC.nsh <a href="https://nsis.sourceforge.io/UAC_plug-in">下载地址</a><br>以上插件下载解压后，将dll文件复制到C:\Program Files (x86)\NSIS\Plugins内，nsh文件复制到C:\Program Files (x86)\NSIS\Include内。</p><h3 id="添加NSIS配置"><a href="#添加NSIS配置" class="headerlink" title="添加NSIS配置"></a>添加NSIS配置</h3><p>下载一个<a href="http://seesawworld.blogspot.sg/2016/02/1-nsis.html">Exmaple这个例子源自</a>，在此鸣谢原作者。<br>这里主要逻辑在Exmaple.nsi内，其他都是一些资源文件，简单修改一下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">; !define 用于声明一个常量</span><br><span class="line">!define PRODUCT_NAME &quot;YuanJin&quot; 产品名称</span><br><span class="line">!define PRODUCT_VERSION &quot;1.0&quot; 版本号</span><br><span class="line">!define PRODUCT_PUBLISHER &quot;YuanJin&quot; 发布者</span><br><span class="line">!define PRODUCT_WEB_SITE &quot;http://www.yuanjin.io/&quot; 产品官网，这将在安装完成后显示在开始程序栏内的快捷键</span><br><span class="line"></span><br><span class="line">!define PRODUCT_STARTUP_APP &quot;YuanJin.exe&quot; 注意更改这个，这个就是你需要打包的exe文件，程序安装完成时将自动执行</span><br><span class="line"></span><br><span class="line">; 主要讲一下依赖，个别程序会需要第三方依赖，我是将第三方依赖加入到DIR_TO_INSTALL中，如下配置</span><br><span class="line">Section &quot;ExampleSection01&quot; SEC01</span><br><span class="line">  CreateDirectory &quot;$SMPROGRAMS\$&#123;PRODUCT_NAME&#125;&quot; </span><br><span class="line">  SetOutPath $INSTDIR</span><br><span class="line">  SetOverwrite try</span><br><span class="line">  File &quot;..\Example\DIR_TO_INSTALL\JsonFx.dll&quot;</span><br><span class="line">  File &quot;..\Example\DIR_TO_INSTALL\JsonFx.xml&quot;</span><br><span class="line">  File &quot;..\Example\DIR_TO_INSTALL\Newtonsoft.Json.dll&quot;</span><br><span class="line">  File &quot;..\Example\DIR_TO_INSTALL\Newtonsoft.Json.xml&quot;</span><br><span class="line">  File &quot;..\Example\DIR_TO_INSTALL\YuanJin.exe.config&quot;</span><br><span class="line">  File &quot;..\Example\DIR_TO_INSTALL\YuanJin.pdb&quot;</span><br><span class="line">  File &quot;favico.ico&quot;</span><br><span class="line">  CreateShortCut &quot;$SMPROGRAMS\$&#123;PRODUCT_NAME&#125;\$(ShortCutUninstall)&quot;  &quot;$INSTDIR\uninst2.exe&quot; &quot;&quot; &quot;$INSTDIR\$&#123;APPLICATION_ICON&#125;&quot; 0</span><br><span class="line">SectionEnd</span><br></pre></td></tr></table></figure><h2 id="打包程序"><a href="#打包程序" class="headerlink" title="打包程序"></a>打包程序</h2><p>现在我们回到桌面，打开NSIS程序，你会看到一个很精致小巧的界面，没错不要怀疑：），雾~<br>点击Complier NSI scripts —-&gt; load script —-&gt;找到刚刚编辑的Exmaple.nsi双击，如果一切正常你将会看到Test Installer可以被点击了。你会在Exmaple/output中看到打包好的exe了。</p><p><a href="http://omega.idv.tw/nsis/Contents.html">NSIS中文文档</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;NSIS是一个Nullsoft脚本安装系统（英语：Nullsoft Scriptable Install System，缩写：NSIS）为一个开放源代码脚本驱动的封装安装档用工具。可以用其脚本语言自定安装的流程，同时支持多种语系的安装接口。</summary>
    
    
    
    <category term="Code" scheme="https://nevermoreluo.github.io/categories/Code/"/>
    
    
    <category term="C#" scheme="https://nevermoreluo.github.io/tags/C/"/>
    
    <category term="NSIS" scheme="https://nevermoreluo.github.io/tags/NSIS/"/>
    
  </entry>
  
  <entry>
    <title>关于Tinc VPN的搭建</title>
    <link href="https://nevermoreluo.github.io/2022/01/06/VPN%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://nevermoreluo.github.io/2022/01/06/VPN%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2022-01-06T19:39:14.000Z</published>
    <updated>2023-09-11T05:43:04.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>Tinc 是一种相对小众的VPN方案。但是支持很多环境的安装，例如ubuntu，centos都可以用自带的包管理工具安装。<span id="more"></span><br>下面是对于Ubuntu的示例</p><h2 id="准备两台（至少）机器"><a href="#准备两台（至少）机器" class="headerlink" title="准备两台（至少）机器"></a>准备两台（至少）机器</h2><p>至少要有一台机器有稳定的公网IP</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在两台机器上都安装tinc<br><code>apt update &amp;&amp; apt install -y tinc</code></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>以下分别命名两台机器为pek，lax<br>下面我们建一个tinc名为test</p><p>网卡tinc0，内网网段设置为172.16.0.0/28</p><h3 id="创建test目录"><a href="#创建test目录" class="headerlink" title="创建test目录"></a>创建test目录</h3><p>两边都执行<br><code>mkdir /etc/tinc/test &amp;&amp; mkdir /etc/tinc/test/hosts</code></p><h3 id="编辑tinc-conf即tinc的配置文件"><a href="#编辑tinc-conf即tinc的配置文件" class="headerlink" title="编辑tinc.conf即tinc的配置文件"></a>编辑tinc.conf即tinc的配置文件</h3><p><code>vim /etc/tinc/test/tinc.conf</code><br>分两部分</p><p>pek写入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Interface = tinc0</span><br><span class="line">Name = pek</span><br><span class="line">Mode = switch</span><br><span class="line">ConnectTo = lax</span><br><span class="line"># In newer versions (&gt;= 1.1) you can use AutoConnect instead</span><br><span class="line"># AutoConnect = yes</span><br></pre></td></tr></table></figure><p>lax写入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Interface = tinc0</span><br><span class="line">Name = lax</span><br><span class="line">Mode = switch</span><br><span class="line"># In newer versions (&gt;= 1.1) you can use AutoConnect instead</span><br><span class="line"># AutoConnect = yes</span><br></pre></td></tr></table></figure><h3 id="编辑tinc-up，即当启用test时需要tinc执行的脚本"><a href="#编辑tinc-up，即当启用test时需要tinc执行的脚本" class="headerlink" title="编辑tinc-up，即当启用test时需要tinc执行的脚本"></a>编辑tinc-up，即当启用test时需要tinc执行的脚本</h3><p><code>vim /etc/tinc/test/tinc-up</code><br>pek写入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set the interface up</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> dev <span class="variable">$INTERFACE</span> up</span><br><span class="line"></span><br><span class="line"><span class="comment"># add transfer networks</span></span><br><span class="line">ip addr add 172.16.0.1/28 dev <span class="variable">$INTERFACE</span> scope <span class="built_in">link</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add routes</span></span><br><span class="line"><span class="comment"># ip route add 172.16.0.0/28 dev $INTERFACE src 172.16.0.2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>lax写入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line"># set the interface up</span><br><span class="line">ip link set dev $INTERFACE up</span><br><span class="line"></span><br><span class="line"># add transfer networks</span><br><span class="line">ip addr add 172.16.0.2/28 dev $INTERFACE scope link</span><br><span class="line"></span><br><span class="line"># add routes</span><br><span class="line"># ip route add 172.16.0.0/28 dev $INTERFACE src 172.16.0.1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="编辑tinc-down，即当关闭test时需要tinc执行的脚本"><a href="#编辑tinc-down，即当关闭test时需要tinc执行的脚本" class="headerlink" title="编辑tinc-down，即当关闭test时需要tinc执行的脚本"></a>编辑tinc-down，即当关闭test时需要tinc执行的脚本</h3><p><code>vim /etc/tinc/test/tinc-down</code><br>两边都键入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">ip link set $INTERFACE down</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="给予tinc-up和tinc-down脚本添加执行权限"><a href="#给予tinc-up和tinc-down脚本添加执行权限" class="headerlink" title="给予tinc-up和tinc-down脚本添加执行权限"></a>给予tinc-up和tinc-down脚本添加执行权限</h3><p><code>chmod +x tinc-*</code></p><h3 id="创建tinc之间交互需要的秘钥，"><a href="#创建tinc之间交互需要的秘钥，" class="headerlink" title="创建tinc之间交互需要的秘钥，"></a>创建tinc之间交互需要的秘钥，</h3><p><code>cd /etc/tinc/test &amp;&amp; tincd -K4096 -n test</code></p><h3 id="交换lax和pek的秘钥"><a href="#交换lax和pek的秘钥" class="headerlink" title="交换lax和pek的秘钥"></a>交换lax和pek的秘钥</h3><p>将lax上的/etc/tinc/test/hosts/lax的内容写入pek的/etc/tinc/test/hosts/lax文件内 并在第一行加入<code>Address=&lt;lax的外网IP&gt;</code><br>将pek上的/etc/tinc/test/hosts/pek的内容写入pek的/etc/tinc/test/hosts/pek文件内 并在第一行加入 <code>Address=&lt;pek的外网IP&gt;</code><br>简单的来说就是交换两台机器彼此的秘钥，并写入IP地址</p><h3 id="将test写入tinc的nets-boot中-并重启tinc"><a href="#将test写入tinc的nets-boot中-并重启tinc" class="headerlink" title="将test写入tinc的nets.boot中,并重启tinc"></a>将test写入tinc的nets.boot中,并重启tinc</h3><p><code>echo &#39;test&#39; &gt;### /etc/tinc/nets.boot &amp;&amp; service tinc restart</code></p><p>之后就可以用ifconfig来查看是否有新加的tinc0网卡，以及IP地址。可以用ping来校验双方是否联通</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.tinc-vpn.org/documentation/tinc.pdf">Tinc doc</a><br><a href="https://dn42.eu/howto/tinc">DN42</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;关于&quot;&gt;&lt;a href=&quot;#关于&quot; class=&quot;headerlink&quot; title=&quot;关于&quot;&gt;&lt;/a&gt;关于&lt;/h2&gt;&lt;p&gt;Tinc 是一种相对小众的VPN方案。但是支持很多环境的安装，例如ubuntu，centos都可以用自带的包管理工具安装。</summary>
    
    
    
    <category term="Code" scheme="https://nevermoreluo.github.io/categories/Code/"/>
    
    
    <category term="VPN" scheme="https://nevermoreluo.github.io/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>Virtualenvwrapper</title>
    <link href="https://nevermoreluo.github.io/2022/01/06/Virtualenvwrapper/"/>
    <id>https://nevermoreluo.github.io/2022/01/06/Virtualenvwrapper/</id>
    <published>2022-01-06T19:31:46.000Z</published>
    <updated>2023-09-11T05:43:04.313Z</updated>
    
    <content type="html"><![CDATA[<p>通过命令<code>pip install virtualenvwrapper</code>安装<span id="more"></span>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将下面代码写入SHELL的环境变量，通过相关搜索得到建议ubuntu用户将其添加如~/.bash_profile文件内，deepin下好像没有，因此我将其添加进了~/.bashrc</span></span><br><span class="line"><span class="built_in">export</span> WORKON_HOME=~/Envs</span><br><span class="line"><span class="built_in">source</span> /usr/local/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure><p>添加好环境变量之后执行如下语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$WORKON_HOME</span> <span class="comment">#为虚拟环境建立一个文件夹，仅第一次需要</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;cd $VIRTUAL_ENV&#x27;</span>&gt;&gt;<span class="variable">$WORKON_HOME</span>/postactivate <span class="comment">#设置进入虚拟环境时的默认目录</span></span><br><span class="line">mkvirtualenv <span class="variable">$envname</span> <span class="comment">#创建一个虚拟环境，和virtual一样可以指定参数例如-p</span></span><br><span class="line">workon <span class="variable">$envname</span> <span class="comment">#实际上当你新建的时候，你就会进入这个虚拟环境，这条命令用于你下一次再进入或切换到envname环境下</span></span><br><span class="line">deactivate <span class="comment">#退出虚拟环境</span></span><br><span class="line">rmvirtualenv <span class="variable">$envname</span> <span class="comment">#删除虚拟环境</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过命令&lt;code&gt;pip install virtualenvwrapper&lt;/code&gt;安装</summary>
    
    
    
    <category term="Code" scheme="https://nevermoreluo.github.io/categories/Code/"/>
    
    
    <category term="python" scheme="https://nevermoreluo.github.io/tags/python/"/>
    
  </entry>
  
</feed>
